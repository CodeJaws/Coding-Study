# 완전 탐색

- 모든 경우의 수를 시도하는 방법
- 경우의 수에 따라 실행 시간이 비례하기 때문에 `입력 값의 범위가 작은 경우 유용`

<br />

## 완전 탐색 알고리즘

### 단순 Brute-Force

- 단순히 반복문 / 조건문으로 모든 경우를 만들어 답을 구하는 방법
- 이런게 있구나만 알아두자.

<br />

### 비트 마스크

- 나올 수 있는 모든 경우의 수가 각각의 우너소가 포함되거나 / 포함되지 않는 2가지 선택으로 구성되는 경우
- ex) 원소가 n개인 집합의 모든 부분 집합을 구한다면, 각 원소가 포함되는지 포함되지 않는지를 0, 1로 구분하여 배열에 저장해둘 수 있음

<br />

### 재귀 함수

- 비트마스크와 마찬가지로 각 원소가 2가지 선택지를 가질 때 유용
- 포함이 되면 해당 원소를 넣어 함수 호출 / 포함되지 않으면 그 상태에서 함수를 호출
- ex) 피보나치 수열
- 시간 복잡도 O(n)

<br />

### 순열

- 서로 다른 N개를 일렬로 나열하는 경우의 수
- 순열의 경우의 수는 N!으로 완전 탐색을 이용하기 위해서는 N이 한자리 수는 되어야 함
- 순열에 원소를 하나씩 채워가는 방식
- 재귀 함수이용
- 시간 복잡도 O(n!)

<br />

### 너비 우선 탐색 (BFS) / 깊이 우선 탐색 (DFS)

- `너비 우선 탐색 (BFS)` : 하나의 요소를 방문하고 그 요소에 인접한 모든 요소를 우선 방문
- `깊이 우선 탐색 (DFS)` : 트리의 한 요소와 다음 수준의 자식노드를 따라가서 방문
- 길 찾기 알고리즘에서 주로 사용 (단순 길찾기는 해당 탐색만 사용해도 되지만 장애물이 나오게 되면 완전 탐색을 병용하기도 한다.)

<img src='https://media.vlpt.us/images/hyehyes/post/06969134-f30c-47ca-a1bd-24449b0ed055/997C3C3E5BD01AF41D.gif' />

<br />

### 너비 우선 탐색 (BFS, Bread-First Search)

- 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘

### 원리

1. 탐색을 시작하는 정점을 큐에 넣는다.
2. 큐가 비어 질때까지 아래과정 반복

- 큐를 가장 앞에 있는 정점(큐에 가장 오래있었던 정점)을 뽑고 그와 연결된 정점을 모두 큐에 넣는다.

```js
1. 처음에 1번으로 시작  큐에 1을 넣는다. '큐: 1'
2. 큐에 가장 앞에 있는 걸 뽑는다.(1번) 1번과 연결되어있는 정점인 '2, 3, 4'를 큐에 넣는다. '큐: 2 3 4'
3. 가장 앞에 있는 걸 뽑는다.(2번) 2번과 연결되어있는 `5`번을 큐에 넣는다. '큐: 3 4 5'
4. 가장 앞에 있는 걸 뽑는다.(3번) 3번과 연결되어있는 '6, 7'번을 큐에 넣는다. '큐: 4 5 6 7'
```

- 이런 식으로 탐색을 반복한다.

<br />

### 장점

1. 비교적 효율적인 운영 가능 / 시간 , 공간 복잡도면에서 안정적
2. 최단 경로를 구할 수 있다.

### 단점

1. 구현이 비교적 까다롭다.

<br />

### 코드

```js
function BFS(graph, start) {
  const visited = []; // 탐색을 마친 노드
  const needVisit = []; // 탐색해야할 노드

  needVisit.push(start); // 노드 탐색 시작

  // 탐색해야할 노드가 남아있다면
  while (needVisit.length !== 0) {
    const node = needVisit.shift(); // 가장 앞에 있는 정점을 뺀다.
    if (!visited.includes(node)) {
      // 해당 노드 방문이 처음이라면
      visited.push(node);
      needVisit = [...needVisit, ...graph[node]];
    }
  }
  return visited;
}
```

<br />

### 깊이 우선 탐색 (DFS)

- 시작점에서 갈 수 있는 정점까지 깊이 있게 파고드는 알고리즘

<img src='https://blog.kakaocdn.net/dn/xC9Vq/btqB8n5A25K/GyOf4iwqu8euOyhwtFuyj1/img.gif' />

<br />

### 원리

- 현재 정점과 연결되 정점들을 하나씩 갈 수 있는지 검사
- 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위 반복 (재귀함수 이용)
- 이 때 방문한 곳을 다시 방문하지 않기 위해 방문한 곳 표시

```js
1. 시작 정점을 1로 결정
2. 1번과 연결되었고 방문 안 한 정점 -> 2번
3. 2번과 연결되었고 방문 안 한 정점 -> 3번
4. 3번과 연결되었고 방문 안 한 정점 -> 4번
5. 4번과 연결되어있는게 없으니 다시 3번으로
6. 3번은 방문 했던 곳이다 2번으로 1번으로
7. 1번은 방문 했던 곳이다. -> 5번으로
-> 이렇게 방문 안한 곳이 없을 때까지 반복
```

<br />

### 장점

- 코드가 직관적이고, 구현하기 쉽다

### 단점

- 깊이가 엄청 깊어지면, 메모리 비용 예측 어려움
- 최단 경로를 알 수 없음

### JS에서 DFS 원리

1. 큐에 시작 정점을 넣는다.
2. 큐에서 가장 오래있던 것을 뽑아낸다. 그와 관련된 것을 큐에 넣는다. 이 때 앞에 넣는다.
3. 큐의 앞에 있는 정점을 뽑아내면서 위 과정 반복
4. 큐가 빌 때까지 계속 반복

<br />

```js
1. 1번으로 시작 -> 1번이 갈 수 있는 곳 ( 2, 5, 9 ) 이걸 큐에 넣는다. '큐: 2 5 9'
2. 큐에 가장 먼저 있는 2번을 뽑아낸다. 연결된 정점인 3번을 큐에 넣는다. '큐: 3 5 9'
3. 큐에 가장 먼저 있는 3번을 뽑아낸다. 연결된 정점인 4번을 큐에 넣는다. '큐: 4 5 9'
4. 해당 과정을 큐가 빌 때까지 반복
```

- 스택을 활용하면 재귀함수를 사용하지 않고 구현 가능

```js
function DFS(graph, start) {
  const visited = []; // 탐색을 마친 노드들
  const needVisit = []; // 탐색해야할 노드들

  needVisit.push(start);

  // 탐색해야할 노드가 남아 있다면
  while (needVisit.length !== 0) {
    const node = needVisit.shift(); // queue이기 때문에 선입선출, shift 사용
    if (!visited.includes(node)) {
      visited.push(node);
      needVisit = [...graph[node], ...needVisit];
    }
  }
  return visited;
}
```
